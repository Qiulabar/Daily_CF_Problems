**提示 1：** 我们相当于要找到权值最大的路径。

**提示 2：** 相当于两个部分在 LCA 会合。

题目中，假设连结的点是 $u,v$ ，则权值等于两者的距离加上 $nums[u],nums[v]$ 。

所以可以直接将问题理解为路径权值，即 $u$ 到 $v$ 的路径权值等于两侧的数值加上中间的边数。

最大化路径权值可以考虑将路径根据 LCA 切分为两个部分，把两部分拼起来。因此我们维护从叶子往根方向的链，其权值等于最深结点的权值加上当前链的长度。

则路径相当于对于某个点选择两条这样的链，其权值相加。于是只需维护最大的两条链即可。这是很容易树上 DP 完成的。

当然也可用某条路径加上最上侧结点。这也是很容易讨论的。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    parent = [-1] + LGMI()
    
    ans = 0
    dp1 = [0] * n
    dp2 = [0] * n
    
    for i in range(n - 1, -1, -1):
        ans = fmax(ans, dp1[i] + dp2[i])
        ans = fmax(ans, nums[i] + dp1[i])
        
        if i > 0:
            v = fmax(nums[i], dp1[i]) + 1
            p = parent[i]
            if v > dp1[p]: dp1[p], dp2[p] = v, dp1[p]
            elif v > dp2[p]: dp2[p] = v
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n), parent(n, -1);

	for (auto &x: nums) cin >> x;
	for (int i = 1; i < n; i ++) cin >> parent[i], parent[i] --;

	int ans = 0;
	vector<int> dp1(n, 0), dp2(n, 0);

	for (int i = n - 1; i >= 0; i --) {
		ans = max(ans, dp1[i] + dp2[i]);
		ans = max(ans, nums[i] + dp1[i]);

		if (i) {
			int v = max(nums[i], dp1[i]) + 1, p = parent[i];
			if (v > dp1[p]) swap(dp1[p], dp2[p]), dp1[p] = v;
			else if (v > dp2[p]) dp2[p] = v;
		}
	}

	cout << ans;

	return 0;
}
```
